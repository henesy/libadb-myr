/*
	Process attrdb(6) files
*/

use std
use bio

pkg adb =
	const ingest	: (f : byte[:]	-> std.result(db,			byte[:]))

	/* Types */

	// An attribute=value pair
	type attribute = struct
		name	: byte[:]
		value	: byte[:]
	;;

	// A tuple composed of attributes
	type tuple = struct
		pairs : attribute[:]
	;;

	// An individual record composed of tuples
	type record = struct
		tuples : tuple[:]
	;;

	// A parsed attrdb database
	type db = struct
		records : record[:]
	;;

	// The results from a query
	type query = union
		`Some
		`None
	;;
;;

/* ???

	Are traits in myr powerful enough to implement find(@f) as :: findable on top of:

		{tuple[:], record[:], attribute[:]}

	???
*/


// Open and parse a file
const ingest = {path : byte[:]
	var f, db

	match bio.open(path, bio.Rd)
	| `std.Ok	file:
		f = file

	| `std.Err	e:
		-> `std.Err e
	;;

	// States for parsing state machine
	type states = union
	`SingleQuote
	`DoubleQuote
	`Comment
	`Newline
	`Key
	`Value
	;;

	// Current state
	var state	= `Newline

	// Last state
	var last	= state

	// Current line for errors - tick by passing \n
	var line	= 1

	// Current character for errors - tick each iteration
	var cn		= 0

	// String builder buffer
	var buf		= std.mksb()	// Memory leak?

	// Parse into db
	for c : bio.bychar(f)
		last = state

		cn++

		if c == '\n'
			line++
			cn = 0
		;;

		std.put("→ {}				({})\n", c, state)

		match state
		| `Comment:
			if c == '\n'
				state = `Newline
			;;

			continue
		| _:
			;
		;;

		match c
		| '#':
			// Allow comments at the beginning of lines and after values
			match last
			| `Newline:
				;
			| `Value:
				;
			| _:
				-> `std.Err std.fmt("invalid comment beginning at {}:{}:{}", path, line, cn)
			;;

			state = `Comment

		| '\n':
			// TODO - commit last value, if any to pair
			var str = std.sbfin(buf)
			std.put("» finished value: {}\n", str)

			state = `Newline
		| '\'':
			state = `SingleQuote
		| '\"':
			state = `DoubleQuote
		| ' ':

			match last
			| `Newline:
				state = `Key
				buf = std.mksb()

			| `Value:
				// TODO - commit value to pair
				var str = std.sbfin(buf)
				std.put("» finished value: {}\n", str)

				state = `Key
				buf = std.mksb()
				;
			| _:
				-> `std.Err std.fmt("invalid space at {}:{}:{}", path, line, cn)
			;;

		| '\t':
			state = `Key
			buf = std.mksb()

			match last
			| `Newline:
				;
			| _:
				-> `std.Err std.fmt("invalid tab at {}:{}:{}", path, line, cn)
			;;

		| '=':
			// TODO - commit key to pair
			var str = std.sbfin(buf)
			std.put("» finished key: {}\n", str)

			state = `Value
			buf = std.mksb()
		| _:
			// A key or value text segment
			match state
			| `Key:
				std.sbputc(buf, c)

			| `Value:
				std.sbputc(buf, c)

			| _:
				match last
				| `Newline:
					state = `Key
					buf = std.mksb()
					std.sbputc(buf, c)

				| _:
					-> `std.Err std.fmt("invalid character at {}:{}:{}", path, line, cn)
				;;
			;;
		;;
	;;

	std.put("{} lines and {} runes\n", line-1, cn)

	-> `std.Ok db
}
